\chapter{Одновременное оценивание движения ВС и систематических ошибок. Алгоритмы параллельной фильтрации процессов, связанных через измерения}
\renewcommand{\headtext}{\thechapter.~Одновременное оценивание движения ВС и систематических ошибок}

В настоящее время в системах УВД для определения параметров движения воздушных судов 
(координаты, скорости, ускорения и т.д.) используются алгоритмы линейного рекуррентного оценивания, 
близкие по используемой математической технике к фильтру Калмана. 
В качестве основного метода применяется алгоритм IMM. 
Главная особенность состоит в том, 
что задача оценки параметров движения для всех ВС, нахоящихся в зоне наблюдения, 
решается независимо для каждого ВС. 
Это полностью соответствует представлению о том, 
что движение каждого ВС никак не зависит от движения других ВС. 
Также это удобно с точки зрения архитектуры программы, 
реализующей систему мультитраекторной обработки --- 
данные, описывающие каждое ВС, можно легко выделить в отдельный объект, 
который можно создавать, удалять и использовать, например, для сравнения 
со вновь поступающими не привязанными к конкретному ВС измернеиями. 
С точки зрения математических алгоритмов, такое разделение также удобно, 
поскольку позволяет оставаться в рамках расчётов в пространстве достаточно низкой размерности 
(4--6 для фильтра Калмана, 15--30 для IMM). 

Наблюдение за движением ВС производится с помощью радиотехнических средств: 
как правило это система из нескольких радиолокаторов и система АЗН-В. 
Реальные измерительные средства, помимо случайных ошибок измерений, 
имеют систематические ошибки. 
Случайные ошибки измерения изначально предусмотрены архитектурой алгоритмов 
рекуррентного оценивания, как фильтра Калмана, так и IMM. 
Систематические ошибки в случае не сложных вариантов их пространственной зависимости 
также легко могут быть включены в алгоритмы оценивания, 
но при их включении обнаруживается одно весьма существенное обстоятельство: 
систематические ошибки одного и того же измерительного средства 
присутствуют в уравнении наблюдения для разных воздушных судов. 
Так, в простом случае связи между неизвестными оцениваемыми состояниями и измерением РЛС 
возникает следующее линейное уравнение наблюдения: 
\begin{gather}
  z_{a \, l}(t) = C^\chi(t) \chi_a(t) + C^\varsigma(t) \varsigma_l(t) + D(t) w_l(t) \,. 
  \label{Bedin:eq:z-simple}
\end{gather}
Здесь $t$ --- момент времени; $a$ --- индекс, обозначающий номер воздушного судна (aircraft); 
$l$ --- индекс радиолокатора (locator); $z_{a l}$ --- вектор измерения; 
$\chi_a$ --- вектор параметров движения ВС; 
$\varsigma_l$ --- вектор параметров, характеризущий состояние РЛС; $w_l(t)$ --- текущая реализация 
случайной ошибки РЛС; $C^\chi(t)$, $C^\varsigma(t)$, $D(t)$ --- матрицы, характеризующие вклад 
каждого параметра на измерение. 

Из вида этого уравнения ясно, что систематическая ошибка локатора $l$ может быть 
оценена только совместно с параметрами движения ВС $a$. 
Но этот радиолокатор наблюдает не только это движение, 
также верно и обратное --- ВС $a$ наблюдается не только радиолокатором $l$. 
Фазовые переменные для разных движений оказываются <<сцепленными>> между собой 
через параметры систематических ошибок. 
Таким образом, система всех движений и всех систематических ошибок нуждается в совместном оценивании. 

Как будет показано далее, даже в простом случае неуправляемых движений, 
стандартные процедуры оптимального совместного оценивания --- 
фильтр Калмана, оценка Гаусса--Маркова --- приводят к соотношениям, 
в которых переменые, относящиеся к разным движениям и систематическим ошибкам, 
существенно связаны друг с другом. 
Это приводит к следующим неприятным последствиям: 
\begin{itemize}
  \item 
  нет возможности задать в программе отдельные объекты для движений разных ВС;
  \item
  затруднено создание и удаление движений;
  \item
  в вычислениях необходимо поддерживать большую матрицу ковариации ошибок оценивания, 
  (в которую входят все кросс-ковариации для ошибок оценивания между различными ВС, 
  между каждым ВС и каждым РЛС и т.д.) это выливается в большие вычислительные затраты. 
\end{itemize}
От требования, чтобы параметры оценивались оптимально, можно отказаться. 
При этом появляется возможность устранить нежелательные эффекты, указанные выше. 
Но в таком случае необходимо тщательно проектировать алгоритм оценивания, 
для того чтобы получаемые оценки были близки к неизвестным истинным параметрам. 

Целью исследования, излагаемого ниже, является создание алгоритма 
лёгкого для параллельной реализации по отдельным воздушным судам, 
при этом обладающим низким уровнем погрешности оценивания. 
Исследование логически продолжает исследование, изложенное в отчёте \cite{otch201505}. 

\section{Описание задачи наблюдения за ВС}

Каждое воздушное судно подчиняется своему уравнению движения 
\begin{gather*}
  d\chi_i(t) = f(t, \chi_i(t), u_i(t))dt + dv_{i}(t)\,, 
\end{gather*}
где $\chi_i$ --- вектор параметров движения ВС; 
$f$ --- функция, задающая скорости движения; 
$u(t)$ --- функция управления; 
$dv_{i}$ --- приращение случайного возмущения для непрерывного варианта динамики. 
В силу того, что наблюдение за ВС ведётся <<в большом масштабе>>, 
вектор $\chi_i$ может содержать не очень большое число параметров, 
а функция $f$ может быть выбрана достаточно простой. 
Измерения при помощи РЛС производятся в дискретные моменты времени, 
поэтому дальше удобно иметь дело с дискретизированным вариантом системы. 
При этом разумно ограничиться динамикой, близкой к линейной 
\begin{gather}
  \chi_i(t_k) = A_i(t_k, \chi_i(t_{k - 1}), u_i(t_k)) \chi_i(t_{k - 1}) + B_i(t_k) v_i(t_k) \,. 
  \label{Bedin:eq:x-small-control-dynamics}
\end{gather}
Здесь $v_i$ --- случайное возмущение; 
$B_i$ --- матричная функция, формирующая влияние случайного возмущения на движение; 
$A_i$ --- матрица, формирующая вид движения системы, зависящая от текущего значения управления $u(t_k)$. 
Моменты времени $t_k$ принадлежат некоторому дискретному множеству $\mathcal{T}$ 
и, на самом деле, определяются по ходу развития движения, т.е. не являются заданными заранее. 

В программе мультирадарной обработки для метода IMM уравнения движения использываются именно в виде 
\eqref{Bedin:eq:x-small-control-dynamics}. 
Далее, будем рассматривать более простую линейную динамику без управления 
\begin{gather}
  \chi_i(t_k) = A_i(t_k) \chi_i(t_{k - 1}) + B_i(t_k) v_i(t_k) \,. 
  \label{Bedin:eq:x-small-dynamics}
\end{gather}

В качестве основного варианта при моделировании будем выбирать 
прямолинейное равномерное движение на плоскости 
\begin{gather}
  \chi_i(t_k) = 
  \begin{bmatrix}
    x_i(t_k) \\ 
    v_i(t_k)
  \end{bmatrix}
  \,, \qquad 
  x_i(t_k), v_i(t_k) \in \mathbb{R}^\mathsf{2} 
  \,, \qquad 
  A_i(t_k) = 
  \begin{bmatrix}
    I_\mathsf{2 \times 2} & (t_k - t_{k - 1}) I_\mathsf{2 \times 2} 
  \end{bmatrix}
  \,, 
  \label{Bedin:eq:straight-line-dynamics}
\end{gather}
где $x_i$, $v_i$ обозначают векторы координат и скорости на плоскости $\mathbb{R}^\mathsf{2}$. 

Формирование наблюдений $z_{i j}$ будем описывать следующим уравнением наблюдения, 
несколько более сложным, чем уравнение \eqref{Bedin:eq:z-simple}: 
\begin{gather}
  z_{i j}(t) = C^\chi(t_k) \chi_i(t_k) + 
  C^\varsigma_j(t_k, \chi_i(t_k)) \varsigma_j(t_k) + 
  D_j(t_k, \chi_i(t_k)) w_j(t_k) \,. 
  \label{Bedin:eq:z-small-dynamics}
\end{gather}
Матрицы $C^\varsigma_j$, $D_j$ для всех имеющих смысл случаев зависят от положения ВС, 
поэтому явно указывается зависимость от $\chi_i$. 
В качестве параметров $\varsigma_j$ могут выступать постоянная систематическая ошибка по дальности 
и азимуту, коэффициент линейной зависимости для систематической ошибки по дальности и т.д. 
Матрица $C^\varsigma_j$ описывает влияние этих неизвестных параметров на измерения. 

Для параметров $\varsigma_j$, характеризующих систематические ошибки РЛС, также введём динамику 
\begin{gather}
  \varsigma_j(t_k) = A^\varsigma_j(t_k) \varsigma_j(t_{k - 1}) + B^\varsigma_i(t_k) v^\varsigma_j(t_k) \,. 
  \label{Bedin:eq:s-small-dynamics}
\end{gather}
Обычно будем принимать $A^\varsigma_j(t_k) \equiv I$, $B^\varsigma_i(t_k) = 0$. 
Матрица $B^\varsigma_i$ характеризует дрейф систематических ошибок со временем. 

Рассмотрим общий фазовый вектор 
\begin{gather}
  \xi(t) = 
  \begin{bmatrix}
    \chi_1(t) \\ \chi_2(t) \\ \vdots \\ \chi_n(t) \\ \varsigma_1(t) \\ \varsigma_2(t) \\ \vdots \\ \varsigma_m(t) 
  \end{bmatrix}
  \,. 
  \label{Bedin:eq:x-s-vector}
\end{gather}
Здесь $n$ и $m$ --- количества наблюдаемых ВС и наблюдающих радиолокаторов. 
Уравнения \eqref{Bedin:eq:x-small-dynamics}, \eqref{Bedin:eq:s-small-dynamics} 
можно переписать как
\begin{multline}
  \xi(t_k) = A(t_k) \xi(t_{k - 1}) + B(t_k) v(t_k) 
  = \\ = 
  \begin{bmatrix}
    A_1(t_k) & & & & & 0 \\
     & \ddots & & & & \\
     & & A_n(t_k) & & & \\ 
    & & & A^\varsigma_1(t_k) & & \\
    & & & & \ddots & \\
    0 & & & & & A^\varsigma_m(t_k) 
  \end{bmatrix}
  \begin{bmatrix}
    \chi_1(t_{k - 1}) \\ \vdots \\ \chi_n(t_{k - 1}) \\ 
    \varsigma_1(t_{k - 1}) \\ \vdots \\ \varsigma_m(t_{k - 1}) 
  \end{bmatrix}
  + \\ + 
  \begin{bmatrix}
    B_1(t_k) & & & & & 0 \\
     & \ddots & & & & \\
     & & B_n(t_k) & & & \\ 
    & & & B^\varsigma_1(t_k) & & \\
    & & & & \ddots & \\
    0 & & & & & B^\varsigma_m(t_k) 
  \end{bmatrix}
  \begin{bmatrix}
    v_1(t_k) \\ \vdots \\ v_n(t_k) \\ 
    v^\varsigma_1(t_k) \\ \vdots \\ v^\varsigma_m(t_k) 
  \end{bmatrix}
  \,,
  \label{Bedin:eq:x-s-big-dynamics}
\end{multline}
где матрицы $A$ и $B$ представляют собой блочно-диагональные матрицы, 
объединяющие все $A_i$, $A^\varsigma_i$ и $B_i$, $B^\varsigma_i$. 

Каждый момент времени $t_k \in \mathcal{T}$ свяжем с некоторым измерением 
$z_{i j}(t_k)$ положения ВС с номером $i$ при помощи радиолокатора $j$. 
Одновременное наблюдение одного ВС несколькими радиолокаторами 
(как и одновременное наблюдение одним радиолокатором нескольких самолётов) 
будем считать пренебрежимо редким событием и не будем вводить его в модель наблюдения. 
Запишем уравнение наблюдения в том виде, как оно должно применяться ко всему большому фазовому вектору. 
\begin{gather}
  z(t_k) = z_{i j}(t_k) = C(t_k) \xi(t_k) + D(t_k) w(t_k) 
  \,, \label{Bedin:eq:z-big-dynamics} \\ 
  C(t_k) = 
  \bordermatrix{
    &   &        &   & i        &   &        &   &              n + j           &   &        &   \cr 
    & 0 & \cdots & 0 & C^x(t_k) & 0 & \cdots & 0 & C^\varsigma_j(t_k, x_i(t_k)) & 0 & \cdots & 0 \cr
  }
  \,, \notag \\ 
  D(t_k) = 
  \bordermatrix{
    &   &        &   &   j                &   &        &   \cr 
    & 0 & \cdots & 0 & D_j(t_k, x_i(t_k)) & 0 & \cdots & 0 \cr
  }
  \,. \notag 
\end{gather}

\section{Уравнения оптимальной фильтрации}

\subsection{Полная система}
Фильтр для фазового вектора. \\

\noindent Этап предсказания:
\[\bar{x}_{t} = A_{x}\hat{x}_{t-1} \]
\[\bar{P}_{x,t} = A_{x}\hat{P}_{x,t-1}A_{x}^T + B_{x}B_{x}^T\]
Этап коррекции:
\[\hat{x}_{t} = \bar{x}_{t} + K_{x}\Lambda(z_{t} - C_{x}\bar{x}_{t} - C_{s}\bar{s}_{t})\]
\[\hat{P}_{x,t} = \bar{P}_{x,t} - K_{x}\Lambda K_{x}^T\]
\[K_{x} = \bar{P}_{x,t}C_{x}^T + \bar{P}_{xs,t}C_{s}^T \] \\
\noindent Фильтр для систематической ошибки. \\


\noindent Этап предсказания:
\[\bar{s}_{t} = A_{s}\hat{s}_{t-1} \]
\[\bar{P}_{s,t} = A_{s}\hat{P}_{s,t-1}A_{s}^T + B_{s}B_{s}^T\]
Этап коррекции:
\[\hat{s}_{t} = \bar{s}_{t} + K_{s}\Lambda(z_{t} - C_{x}\bar{x}_{t} - C_{s}\bar{s}_{t})\]
\[\hat{P}_{s,t} = \bar{P}_{s,t} - K_{s}\Lambda K_{s}^T\]
\[K_{s} = \bar{P}_{s,t}C_{s}^T + \bar{P}_{xs,t}^TC_{x}^T \] 
Обновление блока кросс-ковариации:
\[\bar{P}_{xs,t} = A_{x}\hat{P}_{xs,t-1}A_{s}^T\]
\[\hat{P}_{xs,t} = \bar{P}_{xs,t} - K_{x}\Lambda K_{s}^T\] 
В данном случае для обоих фильтров используется одна матрица $\Lambda$:
\[\Lambda = C_{x}\bar{P}_{x,t}C_{x}^T + C_{s}\bar{P}_{s,t}C_{s}^T + C_{x}\bar{P}_{xs,t}C_{s}^T + 
C_{s}\bar{P}_{xs,t}^TC_{x}^T + DD^T\] 
Уравнение наблюдения:
\[z_{t} = C_{x}x_{t} + C_{s}s_{t} + Dw\]

%\newpage

\section{Упрощеные алгоритмы оценивания по Henk Blom}

В статье \cite{Blom1993} рассматривается точно такая же задача одновременного 
оценивания движения многих ВС и определения систематических ошибок. 
Приводятся варианты упрощения алгоритма фильтрации Калмана, 
показавшие хорошую работу на практике.  

\subsection{Фильтр Калмана для фазового вектора, \\Макро фильтр для систематической ошибки}
\noindent Фильтр для фазового вектора. \\


\noindent Этап предсказания:
\[\bar{x}_{t} = A_{x}\hat{x}_{t-1} \]
\[\bar{P}_{x,t} = A_{x}\hat{P}_{x,t-1}A_{x}^T + B_{x}B_{x}^T\]
Этап коррекции:
\[\hat{x}_{t} = \bar{x}_{t} + K_{x}\Lambda_{x}(z_{t} - C_{x}\bar{x}_{t} - C_{s}\bar{s}_{t})\]
\[\hat{P}_{x,t} = \bar{P}_{x,t} - K_{x}\Lambda_{x} K_{x}^T\] 
Аппроксимация:
\[K_{x} = \bar{P}_{x,t}C_{x}^T \]
\[\Lambda_{x} = C_{x}\bar{P}_{x,t}C_{x}^T + DD^T\] \\
Фильтр для систематической ошибки. \\


\noindent Этап предсказания:
\[\bar{s}_{t} = A_{s}\hat{s}_{t-1} \]
\[\bar{P}_{s,t} = A_{s}\hat{P}_{s,t-1}A_{s}^T + B_{s}B_{s}^T\]
Этап коррекции:
\[\hat{s}_{t} = \bar{s}_{t} + K_{s}\Lambda_{s}(z_{t} - C_{x}\bar{x}_{t} - C_{s}\bar{s}_{t})\]
\[\hat{P}_{s,t} = \bar{P}_{s,t} - K_{s}\Lambda_{s} K_{s}^T\] 
В вычислении матриц $K_{s}$ и $\Lambda_{s}$ используются аппроксимация члена $C_{x}\bar{P}_{xs,t}$:
\[K_{s} = \bar{P}_{s,t}C_{s}^T + H^T \]
\[\Lambda = C_{x}\bar{P}_{x,t}C_{x}^T + C_{s}\bar{P}_{s,t}C_{s}^T + HC_{s}^T + 
C_{s}H^T + DD^T\] \\
Где $H$:
\[F_{x} = \sum_{i = 1}^{M}(D_{i}D_{i}^T)^{-1}\]
\[F_{s} = \sum_{i = 1}^{M}(D_{i}D_{i}^T)^{-1}C_{s,i}\]
\[H = -(F_{x}^TF_{x})^{-1}F_{x}^TF_{s}\bar{P}_{s,t}\] 
Где $M$ - количество радиолокаторов. \\

Уравнение наблюдения:
\[z_{t} = C_{x}x_{t} + C_{s}s_{t} + Dw\]

\newpage

\subsection{Разделённые фильтры для фазового вектора и для систематической ошибки}
\noindent Фильтр для фазового вектора. \\


\noindent Этап предсказания:
\[\bar{x}_{t} = A_{x}\hat{x}_{t-1} \]
\[\bar{P}_{x,t} = A_{x}\hat{P}_{x,t-1}A_{x}^T + B_{x}B_{x}^T\]
Этап коррекции:
\[\hat{x}_{t} = \bar{x}_{t} + K_{x}\Lambda_{x}(z_{t} - C_{x}\bar{x}_{t} - C_{s}\bar{s}_{t})\]
\[\hat{P}_{x,t} = \bar{P}_{x,t} - K_{x}\Lambda_{x} K_{x}^T\] 
Аппроксимация:
\[K_{x} = \bar{P}_{x,t}C_{x}^T \]
\[\Lambda_{x} = C_{x}\bar{P}_{x,t}C_{x}^T + DD^T\] \\
Фильтр для систематической ошибки. \\


\noindent Этап предсказания:
\[\bar{s}_{t} = A_{s}\hat{s}_{t-1} \]
\[\bar{P}_{s,t} = A_{s}\hat{P}_{s,t-1}A_{s}^T + B_{s}B_{s}^T\]
Этап коррекции:
\[\hat{s}_{t} = \bar{s}_{t} + K_{s}\Lambda_{s}(z_{t} - C_{x}\bar{x}_{t} - C_{s}\bar{s}_{t})\]
\[\hat{P}_{s,t} = \bar{P}_{s,t} - K_{s}\Lambda_{s} K_{s}^T\]
Аппроксимация:
\[K_{s} = \bar{P}_{s,t}C_{s}^T \]
\[\Lambda_{s} = C_{s}\bar{P}_{s,t}C_{s}^T + DD^T\]
Уравнение наблюдения:
\[z_{t} = C_{x}x_{t} + C_{s}s_{t} + Dw\]

